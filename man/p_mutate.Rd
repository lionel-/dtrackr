% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dtrackr.R
\name{p_mutate}
\alias{p_mutate}
\title{dplyr modifying operations}
\usage{
p_mutate(.data, ..., .messages = "", .headline = "", .tag = NULL)
}
\arguments{
\item{.data}{A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See \emph{Methods}, below, for
more details.}

\item{...}{<\code{\link[dplyr:dplyr_data_masking]{data-masking}}> Name-value pairs.
The name gives the name of the column in the output.

The value can be:
\itemize{
\item A vector of length 1, which will be recycled to the correct length.
\item A vector the same length as the current group (or the whole data frame
if ungrouped).
\item \code{NULL}, to remove the column.
\item A data frame or tibble, to create multiple columns in the output.
}}

\item{.messages}{a set of glue specs. The glue code can use any global
variable, grouping variable, \{.new_cols\} or \{.dropped_cols\} for changes to
columns, \{.cols\} for the output column names, or \{.strata\}. Defaults to nothing.}

\item{.headline}{a headline glue spec. The glue code can use any global
variable, grouping variable, \{.new_cols\}, \{.dropped_cols\}, \{.cols\} or \{.strata\}.
Defaults to nothing.}

\item{.tag}{if you want the summary data from this step in the future then
give it a name with .tag.}
}
\value{
the .data dataframe after being modified by the \code{dplyr} equivalent
function, but with the history graph updated with a new stage if the
\code{.messages} or \code{.headline} parameter is not empty.
}
\description{
Equivalent \code{dplyr} functions for mutating, selecting and renaming a data set
act in the normal way. mutates / selects / rename generally don't add
anything in documentation so the default behaviour is to miss these out of
the history. This can be overridden with the .messages, or .headline values
in which case they behave just like a \code{comment()} See \code{\link[dplyr:mutate]{dplyr::mutate()}},
\code{\link[dplyr:count]{dplyr::add_count()}}, \code{\link[dplyr:count]{dplyr::add_tally()}}, \code{\link[dplyr:mutate]{dplyr::transmute()}},
\code{\link[dplyr:select]{dplyr::select()}}, \code{\link[dplyr:relocate]{dplyr::relocate()}}, \code{\link[dplyr:rename]{dplyr::rename()}}
\code{\link[dplyr:rename]{dplyr::rename_with()}}, \code{\link[dplyr:arrange]{dplyr::arrange()}} for more details.
}
\examples{
library(dplyr)
library(tidyselect)
library(tidyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# mutate
# In this example we compare the column names of the input and the
# output to identify the new columns created by the mutate operation as
# the `.new_cols` variable
iris \%>\%
  track() \%>\%
  mutate(extra_col = NA_real_,
         .messages="{.new_cols}",
         .headline="Extra columns from mutate:") \%>\%
  history()

# transmute
# Here we do the same for a transmute()
iris \%>\%
  track() \%>\%
  group_by(Species) \%>\%
  transmute(
    sepal.w = Sepal.Width-1,
    sepal.l = Sepal.Length+1,
    .messages="{.new_cols}",
    .headline="New columns from transmute:") \%>\%
  history()

# select
# The output of the select verb (here using tidyselect syntax) can be captured
# and here all column names are being reported with the .cols variable.
iris \%>\%
  track() \%>\%
  group_by(Species) \%>\%
  select(
    starts_with("Sepal"),
    .messages="{.cols}",
    .headline="Output columns from select:") \%>\%
  history()

# relocate, this shows how the columns can be reordered
iris \%>\%
  track() \%>\%
  group_by(Species) \%>\%
  relocate(
    starts_with("Sepal"),
    .after=Species,
    .messages="{.cols}",
    .headline="Order of columns from relocate:") \%>\%
  history()

# rename can show us which columns are new and which have been
# removed (with .dropped_cols)
iris \%>\%
  track() \%>\%
  group_by(Species) \%>\%
  rename(
    Stamen.Width = Sepal.Width,
    Stamen.Length = Sepal.Length,
    .messages=c("added {.new_cols}","dropped {.dropped_cols}"),
    .headline="Renamed columns:") \%>\%
  history()

# rename_with uses a function
iris \%>\%
  track() \%>\%
  group_by(Species) \%>\%
  rename_with(
    .fn = toupper,
    .messages="{.new_cols}",
    .headline="Renamed columns:") \%>\%
  history()

# arrange
# In this case we sort the data descending and show the first value
# is the same as the maximum value.
iris \%>\%
  track() \%>\%
  arrange(
    desc(Petal.Width),
    .messages="{.count} items, columns: {.cols}",
    .headline="Reordered dataframe:") \%>\%
  history()

# add_count
# adding in a count or tally column as a new column
iris \%>\%
  track() \%>\%
  add_count(Species, name="new_count_total",
            .messages="{.new_cols}",
            # .messages="{.cols}",
            .headline="New columns from add_count:") \%>\%
  history()

# add_tally
iris \%>\%
  track() \%>\%
  group_by(Species) \%>\%
  dtrackr::add_tally(wt=Petal.Length, name="new_tally_total",
            .messages="{.new_cols}",
            .headline="New columns from add_tally:") \%>\%
  history()



}
\seealso{
dplyr::mutate()
}
