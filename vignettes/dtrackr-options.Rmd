---
title: "Dtrackr - configuration example"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Dtrackr - configuration example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
library(tidyverse)
library(dtrackr)

knitr::opts_chunk$set(echo = TRUE)
options(dtrackr.strata_glue=NULL)
options(dtrackr.strata_sep=NULL)
options(dtrackr.default_message=NULL)
options(dtrackr.default_headline=NULL)

```

# Global configuration

Most of the behaviour of `dtrackr` can be specified at the individual call level using the `.headline` and `.messages` glue specifications to define a format. Sometimes however this is annoying to do for all the stages in a flow chart and a global configuration of behaviour is desirable.

## Naming conventions for groups

One of the areas where default behaviour may be undesirable is the naming of groups. The default setting combines the group name `{.group}` and the group value `{.value}` into a concatenated colon separated string as demonstrated below:

```{r}

# these are the defaults
options(dtrackr.strata_glue="{.group}:{.value}")
options(dtrackr.strata_sep="; ")

dtrackr::ILPD %>%
  track() %>%
  group_by(Case_or_Control) %>%
  comment() %>%
  group_by(Gender,.add = TRUE) %>%
  comment(
    .messages = c(
    "{.count} patients",
    "{sprintf('%1.0f',.count/.total*100)}% of the total")) %>%
  ungroup() %>%
  flowchart()
```

In particular in situations like this where you are faceting on factors or strings, disposing of the group name may make this clearer. In the following example we only include the group value, force it to lower case, and use a comma to separate multiple facets. We have used manual override of the messages in the grouping stages to specify what we are faceting by in a more natural way:

```{r}

# only include the group value in the description of the group
options(dtrackr.strata_glue="{tolower(.value)}")
options(dtrackr.strata_sep=", ")

dtrackr::ILPD %>%
  track() %>%
  group_by(
    Case_or_Control,
    .messages = "case or control"
  ) %>%
  comment() %>%
  group_by(
    Gender,
    .add = TRUE, 
    .messages = "by {tolower(.cols)}" #.cols contains a csv string of the grouping variables
  ) %>%
  comment(
    .messages = c(
    "{.count} patients",
    "{sprintf('%1.0f',.count/.total*100)}% of the total")) %>%
  ungroup() %>%
  flowchart()

```

N.B. this setting affects the "strata" label of the group, which in turn affects the flowchart branching. If this is not unique from one group to another strange behaviours will be observed.

## Default text

With the group strata label defined you can set other defaults. In the flowchart above the "583 items" labels are generated by the default message setting, and the headings for the groups by the default headline setting. In this example we change these to alter the default text.

```{r}

options(dtrackr.strata_glue="{tolower(.value)}")
options(dtrackr.strata_sep=", ")
options(dtrackr.default_message = "containing {.count} patients")
options(dtrackr.default_headline = "subgroup: {.strata}")


dtrackr::ILPD %>%
  track() %>%
  group_by(
    Case_or_Control,
    .messages = "case or control"
  ) %>%
  comment() %>%
  group_by(
    Gender,
    .add = TRUE, 
    .messages = "by gender"
  ) %>%
  comment(
    .messages = c(
    "{.count} patients",
    "{sprintf('%1.0f',.count/.total*100)}% of the total")) %>%
  ungroup() %>%
  flowchart()

# N.b. this setting includes some unwanted headlines in the ungrouped stages of the flow chart. If a headline evaluates to "" then the headline is suppressed and we can get rid of unwanted headlines. An example of doing this is as follows:
# options(dtrackr.default_headline = "{ifelse(.strata != '', glue::glue('subgroup: {.strata}'), '')}")
```

## Subgroup count

Subgroup counts are a slightly neater way of doing this. Their default layout can be modified using `dtrackr.default_count_subgroup`.

```{r}

options(dtrackr.default_headline = "{.strata}")
options(dtrackr.default_count_subgroup = "{tolower(.name)}: {.count}/{.subtotal}")

dtrackr::ILPD %>%
  track() %>%
  group_by(
    Case_or_Control,
    .messages = "case or control"
  ) %>%
  comment() %>%
  count_subgroup(
    Gender
  ) %>%
  ungroup() %>%
  flowchart()

```

## Exclusions

Elsewhere we discuss the possibility of capturing excluded items for debugging. This behaviour can be added to any pipeline with the `capture_exclusions()` function. Alternatively it can be globally enabled with the following option. Usual caveats about performance apply.

```{r}
options(dtrackr.exclusions=TRUE)
```

## Reporting exclusions which do nothing

Sometimes in a pipeline we have a exclusion criteria which is not triggered, or is not triggered for a particular subgroup. In this case the default is not to show the zero items that were excluded. However sometimes it is reassuring to know that an filter was applied even if it results in nothing:

```{r}
options(dtrackr.show_zero_exclusions=FALSE)
```

## Maximum groupings

in `count_subgroup()` and `group_by()` statements there can be a large number of items generated if a particular grouping variable has a lot of possible values. This can cause performance issues and legibility issues for the resulting graph and is usually a mistake, as a result of an interim stage of the data pipeline (e.g. a `dataset %>% group_by(nearly_unique_id) %>% filter(row_number()==1)` type operation). The most number of groups that `dtrackr` will attempt to keep track of is configurable but defaults to 16:

```{r}
options(dtrackr.max_supported_groupings = 16)
```
